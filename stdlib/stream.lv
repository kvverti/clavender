' A stream represents a lazily evaluated, possibly infinite sequence
' of values. Every stream is driven by a generator, whose values are
' transformed according to the functions applied to the stream.

@import global using _
@import hof using _
@import generator

' Returns a stream that contains the elements of the given generator.
def Stream(gen) => _StreamWrapper(gen, _ExtractingStream)

' The infinite stream of natural numbers.
def Indices() => Stream(generator:of(0, bindRight(\+\, 1)))

(def _BaseStream(transValueImpl) =>
    (def obj(a)
        => (def(f) => _MappingStream(f, \obj)) ; a = \map\
        => (def(f) => _FlatmappingStream(f, \obj)) ; a = \flatmap\
        => (def(f) => _FilteringStream(f, \obj)) ; a = \filter\
        => (def(f) => _TakingStream(f, \obj)) ; a = \takeWhile\
        => (def(b) => _ZippingStream(b, \obj)) ; a = \zip\
        => transValueImpl ; a = \_transValue
        => \_folder ; a = \fold\
    )
)

(def _PostFlatBaseStream(transValueImpl) =>
    (def obj(a)
        => (def(f) => _PostFlatMappingStream(f, \obj)) ; a = \map\
        => (def(f) => _PostFlatFlatmappingStream(f, \obj)) ; a = \flatmap\
        => (def(f) => _PostFlatFilteringStream(f, \obj)) ; a = \filter\
        => (def(f) => _PostFlatTakingStream(f, \obj)) ; a = \takeWhile\
        => (def(f) => _PostFlatZippingStream(f, \obj)) ; a = \zip\
        => transValueImpl ; a = \_transValue
        => \_postFlatFolder ; a = \fold\
    )
)

' Allows easy storage of the source for a stream
(def _StreamWrapper(gen, stream) =>
    (def obj(a)
        => __yes__ ; a = __object__
        ' TODO: fix head/tail for flatmapped streams
        => _head(gen, stream) ; a = \head
        => _tail(gen, stream) ; a = \tail
        => (def q(id, f) => stream(a)(stream, f)(gen, id)) ; a = \fold\
        => (def r(f) => _StreamWrapper(gen, stream(a)(f))) ; sys:typeof(a) = "function"
    )
)

(def _head(gen, stream)
    let val(stream(\_transValue)(gen)(1))
    => val ; sys:defined(val)
)

(def _tail(gen, stream)
    let val(stream(\_transValue)(gen))
    => _StreamWrapper(val(0), stream) ; sys:defined(val)
)

' Extracts a value from the generator.
(def _ExtractingStream() =>
    _BaseStream(
        def(gen) let val(generator:value(gen))
        => { generator:next(gen), val } ; sys:defined(val)
    )
)

(def _FlatmappingStream(flatmapper, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), flatmapper(val(1)) } ; sys:defined(val)
    )
)

(def _PostFlatFlatmappingStream(flatmapper, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), val(1) flatmap flatmapper } ; sys:defined(val)
    )
)

(def _MappingStream(mapper, prev) =>
    _BaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), mapper(val(1)) } ; sys:defined(val)
    )
)

(def _PostFlatMappingStream(mapper, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), val(1) map mapper } ; sys:defined(val)
    )
)

(def _FilteringStream(filterer, prev) =>
    _BaseStream(
        def filt(gen) let val(prev(\_transValue)(gen))
            => sys:undefined ; !sys:defined(val)
            => val ; filterer(val(1))
            => filt(val(0)) ; 1
    )
)

(def _PostFlatFilteringStream(filterer, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), val(1) filter filterer } ; sys:defined(val)
    )
)

' Stream which implements a takeWhile operation.
(def _TakingStream(pred, prev) =>
    _BaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => val ; sys:defined(val) && pred(val(1))
    )
)

(def _PostFlatTakingStream(pred, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), val(1) takeWhile pred } ; sys:defined(val)
    )
)

(def _ZippingStream(other, prev) =>
    _BaseStream(
        def(gen)
            => _zipTransInitial(other, prev, gen) ; sys:typeof(gen) = "function"
            => _zipTransNonInit(other, prev, gen) ; 1
    )
)

(def _zipTransInitial(other, prev, gen)
    let val(prev(\_transValue)(gen)),
        otherVal(head(other))
    => {
        { val(0), tail(other) },
        { val(1), otherVal }
    } ; sys:defined(val) && sys:defined(otherVal)
)

(def _zipTransNonInit(other, prev, gen)
    let val(prev(\_transValue)(gen(0))),
        otherVal(head(gen(1)))
    => {
        { val(0), tail(gen(1)) },
        { val(1), otherVal }
    } ; sys:defined(val) && sys:defined(otherVal)
)

(def _PostFlatZippingStream(other, prev) =>
    _PostFlatBaseStream(
        def(gen)
            => _postFlatZipInitial(other, prev, gen) ; sys:typeof(gen) = "function"
            => _postFlatZipNonInit(other, prev, gen) ; 1
    )
)

(def _postFlatZipInitial(other, prev, gen)
    let val(prev(\_transValue)(gen))
    => {
        { val(0), "..." }, ' How to determine the tail of other?
        val(1) zip other
    } ; sys:defined(val) && sys:defined(other)
)

(def _postFlatZipNonInit(other, prev, gen)
    let val(prev(\_transValue)(gen(0))),
        otherVal(gen(1))
    => {
        { val(0), "..." }, ' ???
        val(1) zip otherVal
    } ; sys:defined(val) && sys:defined(otherVal)
)

' Returns the transformed value for the given generator, using the operations
' defined by the given stream. The result is a vect of two elements: the first
' is the next generator to use, and the second is the resultant value. Returns
' `undefined` if the stream is exhausted with the given generator.
def _transValue(stream, gen) => stream(\_transValue)(gen)

' Helper function for folding streams. The folding stops when the
' value returned by the transformations is `undefined`.
(def _folder(stream, func) =>
    (def impl(gen, ac)
        let val(_transValue(stream, gen))
        => impl(val(0), func(ac, val(1))) ; sys:defined(val)
        => ac ; 1
    )
)

(def _postFlatFolder(stream, func) =>
    (def impl(gen, ac)
        let val(_transValue(stream, gen))
        => impl(val(0), val(1) fold (ac, func)) ; sys:defined(val)
        => ac ; 1
    )
)
