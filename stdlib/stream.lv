' A stream represents a lazily evaluated, possibly infinite sequence
' of values. Every stream is driven by a generator, whose values are
' transformed according to the functions applied to the stream.

@import global using _
@import hof using _
@import generator

(def Stream(gen) =>
    (def obj(a)
        => __yes__ ; a = __object__
        => (def(f) => _MappingStream(f, \obj)) ; a = \map\
        => (def(f) => _FlatmappingStream(f, \obj)) ; a = \flatmap\
        => (def(f) => _FilteringStream(f, \obj)) ; a = \filter\
        => (def(f) => _TakingStream(f, \obj)) ; a = \takeWhile\
        => gen ; a = \_gen
        => (def(gen)
            let val(generator:value(gen))
            => { generator:next(gen), val } ; sys:defined(val)
        ) ; a = \_transValue
        => (def(id, f) => _folder(\obj, f)(gen, id)) ; a = \fold\
    )
)

(def _BaseStream(transValueImpl) =>
    (def obj(a)
        let prev(sys:cval(transValueImpl, 1))
        => __yes__ ; a = __object__
        => (def(f) => _MappingStream(f, \obj)) ; a = \map\
        => (def(f) => _FlatmappingStream(f, \obj)) ; a = \flatmap\
        => (def(f) => _FilteringStream(f, \obj)) ; a = \filter\
        => (def(f) => _TakingStream(f, \obj)) ; a = \takeWhile\
        => prev(a) ; a = \_gen
        => transValueImpl ; a = \_transValue
        => (def(id, f) => _folder(\obj, f)(prev(\_gen), id)) ; a = \fold\
    )
)

(def _PostFlatBaseStream(transValueImpl) =>
    (def obj(a)
        let prev(sys:cval(transValueImpl, 1))
        => __yes__ ; a = __object__
        => (def(f) => _PostFlatMappingStream(f, \obj)) ; a = \map\
        => (def(f) => _PostFlatFlatmappingStream(f, \obj)) ; a = \flatmap\
        => (def(f) => _PostFlatFilteringStream(f, \obj)) ; a = \filter\
        => (def(f) => _PostFlatTakingStream(f, \obj)) ; a = \takeWhile\
        => prev(a) ; a = \_gen
        => transValueImpl ; a = \_transValue
        => (def(id, f) => _postFlatFolder(\obj, f)(prev(\_gen), id)) ; a = \fold\
    )
)

(def _FlatmappingStream(flatmapper, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), flatmapper(val(1)) } ; sys:defined(val)
    )
)

(def _PostFlatFlatmappingStream(flatmapper, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), val(1) flatmap flatmapper } ; sys:defined(val)
    )
)

(def _MappingStream(mapper, prev) =>
    _BaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), mapper(val(1)) } ; sys:defined(val)
    )
)

(def _PostFlatMappingStream(mapper, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), val(1) map mapper } ; sys:defined(val)
    )
)

(def _FilteringStream(filterer, prev) =>
    _BaseStream(
        def filt(gen) let val(prev(\_transValue)(gen))
            => sys:undefined ; !sys:defined(val)
            => val ; filterer(val(1))
            => filt(val(0)) ; 1
    )
)

(def _PostFlatFilteringStream(filterer, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), val(1) filter filterer } ; sys:defined(val)
    )
)

' Stream which implements a takeWhile operation.
(def _TakingStream(pred, prev) =>
    _BaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => val ; sys:defined(val) && pred(val(1))
    )
)

(def _PostFlatTakingStream(pred, prev) =>
    _PostFlatBaseStream(
        def(gen) let val(prev(\_transValue)(gen))
            => { val(0), val(1) takeWhile pred } ; sys:defined(val)
    )
)

' Returns the transformed value for the given generator, using the operations
' defined by the given stream. The result is a vect of two elements: the first
' is the next generator to use, and the second is the resultant value. Returns
' `undefined` if the stream is exhausted with the given generator.
def _transValue(stream, gen) => stream(\_transValue)(gen)

' Helper function for folding streams. The folding stops when the
' value returned by the transformations is `undefined`.
(def _folder(stream, func) =>
    (def impl(gen, ac)
        let val(_transValue(stream, gen))
        => impl(val(0), func(ac, val(1))) ; sys:defined(val)
        => ac ; 1
    )
)

(def _postFlatFolder(stream, func) =>
    (def impl(gen, ac)
        let val(_transValue(stream, gen))
        => impl(val(0), val(1) fold (ac, func)) ; sys:defined(val)
        => ac ; 1
    )
)

def _gen(a) => sys:undefined
